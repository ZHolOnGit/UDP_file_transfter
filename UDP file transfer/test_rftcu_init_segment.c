/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "munit.h"
#include "rft_client_util.h"

static MunitResult test_init_segment_undef_data(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_undef_ack(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_withvals(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_payonly(const MunitParameter params[],    
    void* fixture);
    
static MunitTest tests[] = {
    { "/test_init_segment_undef_data", test_init_segment_undef_data, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_undef_ack", test_init_segment_undef_ack, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_withvals", test_init_segment_withvals, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_payonly", test_init_segment_payonly, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rftcu_init_segment", tests, NULL, 1, MUNIT_SUITE_OPTION_NONE 
};    


int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void set_segment_values(segment_t* seg, seg_type type, int i) {
    seg->type = type;
    seg->sq = i;
    seg->checksum = i * i;
    seg->file_data =  i * i * i;

    for (int j = 0; j < PAYLOAD_SIZE; j++)
        seg->payload[j] = i + j;
}

static bool verify_segment_values(segment_t* seg, seg_type type, int i) {
    return seg->type == type && seg->sq == i && seg->checksum == i * i 
            && seg->file_data == i * i * i; 
}

static bool segment_is_init(segment_t* seg, seg_type type) {
    bool is_init = true;
    
    for (int i = 0; i < PAYLOAD_SIZE; i++)
        is_init = is_init && !seg->payload[i];
    
    return  is_init && !seg->sq && seg->type == type
                && !seg->checksum && !seg->file_data;
}

static MunitResult test_init_segment_undef_data(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.ack.sq = 1;
    init_segment(&proto, DATA_SEG, false);
    assert_true(segment_is_init(&proto.data, DATA_SEG));
    assert_false(segment_is_init(&proto.ack, ACK_SEG));
    assert_int(proto.ack.sq, ==, 1);

    return MUNIT_OK;
}

static MunitResult test_init_segment_undef_ack(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.data.sq = 1;
    init_segment(&proto, ACK_SEG, false);
    assert_true(segment_is_init(&proto.ack, ACK_SEG));
    assert_false(segment_is_init(&proto.data, DATA_SEG));
    assert_int(proto.data.sq, ==, 1);

    return MUNIT_OK;
}

static MunitResult test_init_segment_withvals(const MunitParameter params[],    
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);
        set_segment_values(&proto.ack, ACK_SEG, i);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, false);

        assert_true(segment_is_init(&proto.data, DATA_SEG));

        assert_false(segment_is_init(&proto.ack, ACK_SEG));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.ack.payload[j], ==, i + j);
        }
    }

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);
        set_segment_values(&proto.ack, ACK_SEG, i + 1);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, false);

        assert_true(segment_is_init(&proto.ack, ACK_SEG));

        assert_false(segment_is_init(&proto.data, DATA_SEG));
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
        }
    }

    return MUNIT_OK;
}
    
static MunitResult test_init_segment_payonly(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);        
        set_segment_values(&proto.ack, ACK_SEG, i);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, 0);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
    }
        
    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);        
        set_segment_values(&proto.ack, ACK_SEG, i + 1);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, 0);
        }
    }
    
    return MUNIT_OK;
}

