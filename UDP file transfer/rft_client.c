/******** DO NOT EDIT THIS FILE ********/
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <math.h>
#include "rft_client_logging.h"

#define MIN_ARGC 6

/*
 * This file contains the main function for the client.
 * Do NOT change anything in this file.
 * 
 * For a usage message for the client type:
 * 
 *      rft_client
 *    
 * this will output a message explaining the command line options.
 *
 * Or start client as:
 *
 *      rft_client <input_file> <output_file> <server_addr> <port> 
 *                  <nm|wt loss_probability>  
 *
 * Where:
 *      input_file is the file to send
 *      output_file is name for the file on the server
 *      server_addr is the address of the server
 *      port is the port the server is listening on
 *      nm selects normal transfer mode
 *      wt selects transfer with time out and a probability of loss or 
 *          corruption of segments. The probability must be between 0.0 and 1.0,
 *          inclusive.
 *
 * Only specify one transfer mode. That is, either nm or wt with a loss 
 * probability.      
 */

/* helper functions to process command line arguments and report errors */
static void process_argv(protocol_t* proto, int argc, char** argv);
static void exit_err_msg(int src_line, protocol_t* proto, char* err_msg);
static void exit_einval(int src_line, protocol_t* proto, char* err_msg);
static void exit_usage(char* arg0);

/* the main function and entry point for rft_client */
int main(int argc,char *argv[]) {
    srand((unsigned) time(NULL));    // seed PRNG for is_corrupted function
    
    protocol_t proto;
    init_protocol(&proto);

    process_argv(&proto, argc, argv);
    
    log_protocol(__FILE__, __LINE__, &proto);
          
    struct stat sbuf;
    int r = stat(proto.in_fname, &sbuf);

    if (r < 0)
        exit_err_msg(__LINE__, &proto, "Could not stat input file");
    
    proto.fsize = sbuf.st_size;
    proto.tfr_bytes = (size_t) proto.fsize;
    
    /* try opening input file */
    proto.in_file = fopen(proto.in_fname, "r");
    
    if (!proto.in_file)
        exit_err_msg(__LINE__, &proto, "Could not open input file");
        
    /* set UDP socket and server information */
    proto.state = set_udp_socket(&proto); 
    
    if (proto.state != PS_TFR_READY)
        exit_einval(__LINE__, &proto, 
            "Could not set socket or proto.server_addr is invalid");

    log_protocol(__FILE__, __LINE__, &proto);

    /* Send meta data to the server */
    proto.state = send_metadata(&proto);
    if (proto.state != PS_META_SENT)
        exit_err_msg(__LINE__, &proto, "Sending metadata failed");
    
    proto.state = proto.send_file_op(&proto);
    
    log_protocol(__FILE__, __LINE__, &proto);
    
    log_separator(&proto);
    
    proto.close(&proto);
    
    exit(EXIT_SUCCESS);
} 

static void process_argv(protocol_t* proto, int argc, char** argv) {
    if (argc < MIN_ARGC)
        exit_usage(argv[0]);

    int next_arg = 1;
    char* log_name = NULL;
    
    if (!strncmp(argv[next_arg], "-q", 3)) {
        if (argc < MIN_ARGC + 1)
            exit_usage(argv[0]);
            
        proto->log = NULL;
        next_arg++;
    } else if (!strncmp(argv[next_arg], "-o", 3)) {
        if (argc < MIN_ARGC + 2)
            exit_usage(argv[0]);
            
        next_arg++;
        log_name = argv[next_arg];
        
        if (strnlen(log_name, MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
            exit_einval(__LINE__, proto, 
                "Log file name is longer than max length");

        next_arg++;
    }

    if (strnlen(argv[next_arg], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_einval(__LINE__, proto, 
            "Input file name is longer than max length");
    
    snprintf(proto->in_fname, MAX_FILENAME_SIZE, "%s", argv[next_arg]);
    
    next_arg++;
    
    if (strnlen(argv[next_arg], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_einval(__LINE__, proto,
            "Output file name is longer than max length");

    snprintf(proto->out_fname, MAX_FILENAME_SIZE, "%s", argv[next_arg]);
    
    next_arg++;

    if (strnlen(argv[next_arg], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_einval(__LINE__, proto, 
            "Server address is longer than max length");

    snprintf(proto->server_addr, MAX_FILENAME_SIZE, "%s", argv[next_arg]);
    
    next_arg++;
    
    proto->server_port = atoi(argv[next_arg]);
    if (proto->server_port < PORT_MIN || proto->server_port > PORT_MAX)
        exit_einval(__LINE__, proto, "Port is outside valid range");

    next_arg++;
    
    proto->tfr_mode = argv[next_arg];
    
    if (argc == next_arg + 1
            && !strncmp(proto->tfr_mode, NORMAL_TFR_MODE, TFR_MODE_SIZE))
        proto->send_file_op = send_file_normal;
    
    if (argc == next_arg + 2 
            && !strncmp(proto->tfr_mode, TIMEOUT_TFR_MODE, TFR_MODE_SIZE)) {
        proto->send_file_op = send_file_with_timeout;
        proto->loss_prob = atof(argv[next_arg + 1]);

        if (signbit(proto->loss_prob) || isgreater(proto->loss_prob, 1.0))
            exit_einval(__LINE__, proto, 
                "Loss probability is outside valid range");
    }
    
    if (!proto->send_file_op)
        exit_einval(__LINE__, proto, "Invalid transfer mode");  
        
    if (log_name) {
        proto->log = fopen(log_name, "w");
        if (!proto->log) 
            proto->log = stdout;
    }
}

static void exit_err_msg(int src_line, protocol_t* proto, char* err_msg) {
    proto->err_msg = err_msg;
    exit_err(__FILE__, src_line, proto);
}

static void exit_einval(int src_line, protocol_t* proto, char* err_msg) {
    errno = EINVAL;
    exit_err_msg(src_line, proto, err_msg);
}
        
static void exit_usage(char* arg0) {
    printf("usage: %s [-q | -o log_file] <input_file> <output_file> "
        "<server_addr> <port> <nm|wt loss_prob>\n", arg0);
    printf("       -q: quiet, no logging output\n");
    printf("       -o log_file: logging to log_file (not stdout)\n");
    printf("       input_file is the file to send\n");
    printf("       input_file is the file to send\n");
    printf("       output_file is name for the file on the server\n");
    printf("       server_addr is the address of the server\n");
    printf("       port is the port the server is listening on\n");
    printf("       nm selects normal transfer, or:\n");
    printf("       wt selects transfer with time out \n");
    printf("          and the given probability of loss (loss_prob) "
                      "between 0.0 and 1.0\n");
    printf("Note: if neither -q or -o are selected, logging is to stdout\n");
    exit(EXIT_FAILURE);
}
