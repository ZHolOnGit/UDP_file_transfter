/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "munit.h"
#include "rft_client_util.h"

char* in1data[] = { "a" };
char* in17data[] = { "hello hello hello" };
char* in34data[] = { "hello\ngoodbye\ntest 34 char payload" };
char* in35data[] = { "hello\ngoodbye\ntest 35 char payload\n" };
char* in36data[] = { "hello goodbye test 36 char payload!", "!" };
char* in350data[] = {
    "n this module you will gain an unde",
    "rstanding of operating system and n",
    "etwork design and implementation. A",
    "s outlined above, this is an import",
    "ant topic in itself.\nIt is also imp",
    "ortant because of what it teaches u",
    "s about good systems and applicatio",
    "ns design in general\n\tMany of the a",
    "spects of computer science - abstra",
    "ction, algorithm design and choice "
};
char* in660data[] = {
    "We\nall\nuse operating systems and ne",
    "tworks every day, when we use a mob",
    "ile phone, tablet, laptop, or any n",
    "umber of other computing devices. A",
    "n ordinary user may not\nbe\ninterest",
    "ed in how the operating sy\nstem of ",
    "a device they use works and may not",
    " even know the operating system exi",
    "sts.\n\n\tAs computer scientists we bo",
    "th should be interested in how they",
    " work and need to know how they wor",
    "k.\n\nFor example, it is not possible",
    " to detect and protect against cybe",
    "r attacks without an understanding ",
    "of operating systems and networks.\n",
    "\nIf you want to resolve performance",
    " or reliability problems, you need ",
    "an understanding of the role of ope",
    "rating systems and networks.\n\n"
}; 

typedef struct input {
    char* fname;
    size_t fsize;
    char** data;
    int reads_required;
} input_t;

input_t input_setup[] = {
    { "in1.txt", 1, in1data, 1},
    { "in17.txt", 17, in17data, 1},
    { "in34.txt", 34, in34data, 1},
    { "in35.txt", 35, in35data, 1},
    { "in36.txt", 36, in36data, 2},
    { "in350.txt", 350, in350data, 10},
    { "in660.txt", 660, in660data, 19},
};

typedef enum input_idx {
    INPUT_SZ_1,
    INPUT_SZ_17,
    INPUT_SZ_34,
    INPUT_SZ_35,
    INPUT_SZ_36,
    INPUT_SZ_350,
    INPUT_SZ_660
} input_idx_t;

static void* setup(const MunitParameter params[], void* user_data);

static void tear_down(void* fixture);

static MunitResult read_input_file(protocol_t* proto, input_idx_t in_idx);

static MunitResult test_read_data_in1(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in17(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in34(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in35(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in36(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in350(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_in660(const MunitParameter params[], 
    void* fixture);
static MunitResult test_read_data_err(const MunitParameter params[], 
    void* fixture);
    
static MunitTest tests[] = {
     { "/test_read_data_in1", test_read_data_in1, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in17", test_read_data_in17, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in34", test_read_data_in34, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in35", test_read_data_in35, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in36", test_read_data_in36, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in350", test_read_data_in350, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_in660", test_read_data_in660, setup, tear_down, 
        MUNIT_TEST_OPTION_NONE, NULL },
     { "/test_read_data_err", test_read_data_err, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rftcu_read_data", tests, NULL, 1, MUNIT_SUITE_OPTION_NONE 
};    

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void* setup(const MunitParameter params[], void* user_data) {
    protocol_t* proto = (protocol_t*) malloc(sizeof(protocol_t));
    return proto;
}

static void tear_down(void* fixture) {
    protocol_t* proto = (protocol_t*) fixture;
    fclose(proto->in_file);
    free(fixture);
}

static MunitResult read_input_file(protocol_t* proto, input_idx_t in_idx) {
    munit_logf(MUNIT_LOG_DEBUG, "input file %d: %s", in_idx,
        input_setup[in_idx].fname);

    proto->in_file = fopen(input_setup[in_idx].fname, "r");
    proto->tfr_bytes = input_setup[in_idx].fsize;
    
    size_t total_bytes_read = 0;
    
    assert_not_null(proto->in_file);

    int i = 0;
    while (proto->tfr_bytes) {
        size_t exp_file_data = proto->tfr_bytes < PAYLOAD_SIZE 
                ? proto->tfr_bytes : PAYLOAD_SIZE - 1;

        proto_state ps = read_data(proto);
    
        assert_int(ps, ==, PS_DATA_READ);
        assert_size(proto->data.file_data, ==, exp_file_data);
        assert_char(proto->data.payload[PAYLOAD_SIZE-1], ==, 0);
        assert_int(strnlen(proto->data.payload, PAYLOAD_SIZE+1), ==,
            proto->data.file_data);
        assert_string_equal(proto->data.payload, input_setup[in_idx].data[i]);
        
        munit_logf(MUNIT_LOG_DEBUG, "payload %d: %s", i, proto->data.payload);
        
        total_bytes_read += proto->data.file_data;
        i++;
    }
    
    assert_size(proto->tfr_bytes, ==, 0);
    assert_size(total_bytes_read, ==, input_setup[in_idx].fsize);
    assert_int(i, ==, input_setup[in_idx].reads_required);
    
    return MUNIT_OK;
}

static MunitResult test_read_data_in1(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_1);
}

static MunitResult test_read_data_in17(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_17);
}

static MunitResult test_read_data_in34(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_34);
}

static MunitResult test_read_data_in35(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_35);
}

static MunitResult test_read_data_in36(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_36);
}

static MunitResult test_read_data_in350(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_350);
}

static MunitResult test_read_data_in660(const MunitParameter params[], 
    void* fixture) {
    return read_input_file((protocol_t*) fixture, INPUT_SZ_660);
}

static MunitResult test_read_data_err(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;

    proto.in_file = fopen("inerr.txt", "a");
    assert_int(read_data(&proto), ==, PS_BAD_READ);
    fclose(proto.in_file);

    return MUNIT_OK;
}
