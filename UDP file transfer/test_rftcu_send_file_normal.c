/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>

#include "munit.h"
#include "rft_client_logging.h"
#include "rft_client_util.h"

#define DEFAULT_PORT 20333
#define ACK_SIZE 3

#define EXP_TFR_BYTES 660
#define EXP_SEG_COUNT 19

char* in660data[] = {
    "We\nall\nuse operating systems and ne",
    "tworks every day, when we use a mob",
    "ile phone, tablet, laptop, or any n",
    "umber of other computing devices. A",
    "n ordinary user may not\nbe\ninterest",
    "ed in how the operating sy\nstem of ",
    "a device they use works and may not",
    " even know the operating system exi",
    "sts.\n\n\tAs computer scientists we bo",
    "th should be interested in how they",
    " work and need to know how they wor",
    "k.\n\nFor example, it is not possible",
    " to detect and protect against cybe",
    "r attacks without an understanding ",
    "of operating systems and networks.\n",
    "\nIf you want to resolve performance",
    " or reliability problems, you need ",
    "an understanding of the role of ope",
    "rating systems and networks.\n\n",
    NULL
}; 

static MunitResult test_send_file_normal_empty(
    const MunitParameter params[], void* fixture);
static MunitResult test_send_file_normal(const MunitParameter params[], 
    void* fixture);
    
/* struct to capture transfer information for report */
typedef struct trans_inf {
    off_t file_size;        // size of file being transferred
    size_t valid_payload;   // total valid bytes of payload
    int total_segs;         // total segments received
    int corrupt_segs;       // total corrupted segments
    int expected_sq;        // record of expected sequence number
    int data_idx;           // index of expected data line
} trans_inf_t;

static int bind_server(uint16_t port);
static void run_server(pid_t cpid, int sockfd, trans_inf_t* tr_inf);
static proto_state run_client(pid_t ppid, uint16_t port);

static MunitTest tests[] = {
    { "/test_send_file_normal_empty", test_send_file_normal_empty, 
        NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_send_file_normal", test_send_file_normal, 
        NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },

    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rftcu_send_file_normal", tests, NULL, 1,
        MUNIT_SUITE_OPTION_NONE 
};    

int main(int argc, char** argv) {
    uint16_t srvr_port = DEFAULT_PORT;
    if (argc == 2) {
        srvr_port = atoi(argv[1]);
        argv[1] = NULL;
        argc = 1;
    }
    
    return munit_suite_main(&suite, &srvr_port, argc, argv);
}

static MunitResult test_send_file_normal_empty(
    const MunitParameter params[], void* fixture) {
    protocol_t proto;
    
    proto.fsize = 0;
    
    assert_int(send_file_normal(&proto), ==, PS_EMPTY_FILE);
    
    return MUNIT_OK;    
}


static MunitResult test_send_file_normal(const MunitParameter params[], 
    void* fixture) {
    uint16_t* port = (uint16_t*) fixture;
    
    int srvr_sockfd = bind_server(*port);

    pid_t ppid = getpid();
    pid_t cpid = fork();
    
    if (cpid < -1) 
        return MUNIT_FAIL;

    if (cpid == 0) {
        exit(run_client(ppid, *port));
    } else {
        int cstatus;
        trans_inf_t tr_inf;
        run_server(cpid, srvr_sockfd, &tr_inf);
        
        assert_size(tr_inf.valid_payload, ==, EXP_TFR_BYTES);
        assert_int(tr_inf.total_segs - tr_inf.corrupt_segs, ==, EXP_SEG_COUNT);
        assert_int(tr_inf.expected_sq, ==, EXP_SEG_COUNT);
        assert_int(tr_inf.data_idx, ==, EXP_SEG_COUNT);
    
        waitpid(cpid, &cstatus, 0);
        
        if (WIFEXITED(cstatus))
            assert_int(WEXITSTATUS(cstatus), ==, PS_TFR_COMPLETE);
    }

    return MUNIT_OK;
}

void c_exit_err(pid_t ppid, protocol_t* proto, int init_errno, char* msg,
    int line) {
    printf("killing server\n");
    kill(ppid, SIGKILL);

    errno = init_errno;
    if (proto->in_file) fclose(proto->in_file);
    if (proto->sockfd != -1) close(proto->sockfd);
    
    munit_errorf("CLIENT ERROR: %s at line: %d", msg, line);
    exit(EXIT_FAILURE);
}

static void ip_4t(protocol_t* proto) {
    memset(proto, 0, sizeof(protocol_t));
    proto->state = PS_INIT;
    proto->in_file = NULL;
    proto->sockfd = -1;
    proto->seg_size = sizeof(segment_t);
    proto->sockaddr_size = (socklen_t) sizeof(struct sockaddr_in); 
    proto->timeout_sec = DEFAULT_TIMEOUT;
    proto->curr_retry = 0;
    proto->max_retries = DEFAULT_RETRIES;
    
    memset(&proto->ack, 0, proto->seg_size);
    proto->ack.type = ACK_SEG;
    memset(&proto->data, 0, proto->seg_size);
    proto->data.type = DATA_SEG;
}

static bool smd_4t(protocol_t* proto) {     
    metadata_t file_inf;
    size_t metadata_size = sizeof(metadata_t);
    file_inf.size = proto->fsize;
    
    snprintf(file_inf.name, MAX_FILENAME_SIZE, "%s", proto->out_fname);
    
    return metadata_size == sendto(proto->sockfd, &file_inf, metadata_size, 0, 
                    (struct sockaddr *) &proto->server, proto->sockaddr_size);
} 

static void sudp_4t(protocol_t* proto) {  
    proto->sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    if (proto->sockfd != -1) {
        proto->server.sin_family = AF_INET;
        proto->server.sin_port = htons(proto->server_port);
        
        if (!inet_aton(proto->server_addr, &proto->server.sin_addr)) {
            close(proto->sockfd);
            proto->sockfd = -1;
            return;
        } else {
            proto->state = PS_TFR_READY;
        }
    }
} 

static proto_state run_client(pid_t ppid, uint16_t port) {
    sleep(1);

    protocol_t proto;

    /* initialise protocol */
    ip_4t(&proto);
    
    snprintf(proto.in_fname, MAX_FILENAME_SIZE, "%s", "in660.txt");
    snprintf(proto.out_fname, MAX_FILENAME_SIZE, "%s", "out/out.txt");
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", "127.0.0.1");
    proto.server_port = port;
    proto.tfr_mode = "nm";
    proto.loss_prob = 0.0;
    proto.log = stdout;
    srand((unsigned) time(NULL));    // seed PRNG for is_corrupted function
    
    printf("\n");
    log_protocol(__FILE__, __LINE__, &proto);
    proto.log = NULL;
    struct stat sbuf;
    int r = stat(proto.in_fname, &sbuf);
    if (r < 0)
        c_exit_err(ppid, &proto, errno, "Could not stat input file",  __LINE__);
    
    proto.fsize = sbuf.st_size;
    proto.tfr_bytes = (size_t) proto.fsize;
    
    /* try opening input file */
    proto.in_file = fopen(proto.in_fname, "r");
    
    if (!proto.in_file)
        c_exit_err(ppid, &proto, errno, "Could not open input file", __LINE__);
        
    /* set UDP socket and server information */
    sudp_4t(&proto);
    
    if (!proto.state)
        c_exit_err(ppid, &proto, EINVAL, 
            "Could not set socket or proto.server_addr is invalid", __LINE__);
    
    /* Send meta data to the server */
    if (!smd_4t(&proto))
        c_exit_err(ppid, &proto, errno, "Sending metadata failed", __LINE__);
    
    proto_state ps = send_file_normal(&proto);
        
    fclose(proto.in_file);
    
    close(proto.sockfd);
    
    return ps;
}

#define INF_MSG_SIZE 256    // max size of information messages to print out

static void s_receive_file(pid_t cpid, int sockfd, struct sockaddr_in* client, 
    metadata_t* file_inf, trans_inf_t* tr_inf);

static bool s_process_data_msg(pid_t cpid, int sockfd, 
    struct sockaddr_in* client, segment_t* data_msg, trans_inf_t* tr_inf);

static void s_exit_err(pid_t cpid, int sockfd, char* msg, int line);    
                                                // exit with error message
static void s_print_summary(metadata_t* file_inf, trans_inf_t* tr_inf);

static int bind_server(uint16_t port) {
    if (port < PORT_MIN || port > PORT_MAX) 
        s_exit_err(-1, -1, "Port is outside valid range", __LINE__);
    
    /* create a socket */
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    
    if (sockfd == -1)
        s_exit_err(-1, -1, "Failed to open socket", __LINE__); 
        
    /* set up address structure */
    struct sockaddr_in server;
    socklen_t sock_len = (socklen_t) sizeof(struct sockaddr_in); 
    memset(&server, 0, sock_len);
    
    /* Fill in the server address structure */
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
    server.sin_port = htons(port);
    
    /* bind/associate the socket with the server address */
    if(bind(sockfd, (struct sockaddr *) &server, sock_len)) {
        close(sockfd);
        printf("***********\nIMPORTANT: bind failed\n"
            "this is NOT a student error, try starting the test with a "
            "different port instead of: %d\n***********\n", port);
        exit(EXIT_FAILURE);
    }
    
    return sockfd;
}

static void run_server(pid_t cpid, int sockfd, trans_inf_t* tr_inf) {
    char inf_msg_buf[INF_MSG_SIZE];              
    metadata_t file_inf;
    size_t metadata_size = sizeof(metadata_t);
    memset(&file_inf, 0, sizeof(metadata_t));
    struct sockaddr_in client;
    socklen_t sock_len = (socklen_t) sizeof(struct sockaddr_in); 
    socklen_t addr_len = sock_len;
    memset(&client, 0, sock_len);
    ssize_t bytes = -1;

    //receive metadata from the client    
    bytes = recvfrom(sockfd, &file_inf, metadata_size, 0, 
                    (struct sockaddr*) &client, &addr_len);
                    
    if (bytes != metadata_size) {
        snprintf(inf_msg_buf, INF_MSG_SIZE, 
            "Expected metadata size %zd bytes, received %zd bytes",
                metadata_size, bytes);
        s_exit_err(sockfd, cpid, inf_msg_buf, __LINE__);
    } else if (!file_inf.name[0] || file_inf.size < 0) {
        errno = EINVAL;
        s_exit_err(sockfd, cpid, "Metadata file name is empty or size < 0", 
            __LINE__);
    }
    
    tr_inf->file_size = file_inf.size;
    tr_inf->valid_payload = 0;
    tr_inf->total_segs = 0;
    tr_inf->corrupt_segs = 0;
    tr_inf->expected_sq = 0;
    tr_inf->data_idx = 0;
    
    s_receive_file(cpid, sockfd, &client, &file_inf, tr_inf);
    
    close(sockfd);
    
    s_print_summary(&file_inf, tr_inf);
}

static void s_receive_file(pid_t cpid, int sockfd, struct sockaddr_in*
    metadata_client, metadata_t* file_inf, trans_inf_t* tr_inf) {
    socklen_t addr_len = (socklen_t) sizeof(struct sockaddr_in);
    segment_t data_msg;
    char inf_msg_buf[INF_MSG_SIZE];

    bool receiving = true;
    size_t seg_size = sizeof(segment_t);
    
    /* while still receiving segments */
    while (receiving) {
        struct sockaddr_in client;
        socklen_t client_addr_len = addr_len;
        memset(&data_msg, 0, seg_size);
        memset(&client, 0, addr_len);
        ssize_t bytes = recvfrom(sockfd, &data_msg, seg_size, 0,
                        (struct sockaddr*) &client, &client_addr_len);
        
        if (bytes != seg_size) {
            snprintf(inf_msg_buf, INF_MSG_SIZE, 
                "Expected data message size %zd bytes, received %zd bytes",
                seg_size, bytes);
            s_exit_err(cpid, sockfd, inf_msg_buf, __LINE__);
        } 
        
        if (client_addr_len != addr_len 
            || client.sin_family != metadata_client->sin_family
            || client.sin_port != metadata_client->sin_port
            || client.sin_addr.s_addr != metadata_client->sin_addr.s_addr) {
            s_exit_err(cpid, sockfd, 
                "Client that sent metadata does not match client sending data",
                __LINE__);
        }
        
        receiving = s_process_data_msg(cpid, sockfd, &client, &data_msg,
            tr_inf);
            
///#ifdef _SILENCE_LOGGING
        printf(".");
        fflush(stdout);
//#endif
    }
    
}

static bool s_process_data_msg(pid_t cpid, int sockfd, 
    struct sockaddr_in* client, segment_t* data_msg, trans_inf_t* tr_inf) {
    bool receiving = true;
    char inf_msg_buf[INF_MSG_SIZE];
    size_t seg_size = sizeof(segment_t);
    
    tr_inf->total_segs++;

    if (data_msg->sq != tr_inf->expected_sq) {
        snprintf(inf_msg_buf, INF_MSG_SIZE, 
            "Data message sequence number: %d != expected sequence number: %d",
            data_msg->sq, tr_inf->expected_sq);
        s_exit_err(cpid, sockfd, inf_msg_buf, __LINE__);
    }
    
    if (data_msg->payload[PAYLOAD_SIZE - 1]) {
        errno = EINVAL;
        s_exit_err(cpid, sockfd, "Payload not terminated", __LINE__);
    }

    size_t payload_len = strnlen(data_msg->payload, PAYLOAD_SIZE);
    
    if (payload_len != data_msg->file_data) {
        errno = EINVAL;
        snprintf(inf_msg_buf, INF_MSG_SIZE, 
            "Segment file data is: %zd bytes\nactual size: %zd",
            data_msg->file_data, payload_len);
        s_exit_err(cpid, sockfd, inf_msg_buf, __LINE__);
    }
            
    int cs = checksum(data_msg->payload, false);

    /* 
     * If the calculated checksum is same as that of received 
     * checksum then send corresponding ack
     */
    if (cs == data_msg->checksum) {
        tr_inf->valid_payload += data_msg->file_data;
        
        /* is there still data to receive */
        receiving = tr_inf->file_size > tr_inf->valid_payload; 
        
        /* check the payload as expected */
        if (strncmp(data_msg->payload, in660data[tr_inf->data_idx], 
            PAYLOAD_SIZE + 1)) {
            snprintf(inf_msg_buf, INF_MSG_SIZE, 
                "Payload: \"%s\" not same as expected data: \"%s\"",
                    data_msg->payload, in660data[tr_inf->data_idx]);
            s_exit_err(cpid, sockfd, inf_msg_buf, __LINE__);
        }        
        
        tr_inf->data_idx++;
        
        /* Prepare the Ack segment */
        segment_t ack_msg;
        memset(&ack_msg, 0, seg_size);
        ack_msg.sq = data_msg->sq;
        ack_msg.type= ACK_SEG;
    
        /* Send the Ack segment */
        ssize_t bytes = sendto(sockfd, &ack_msg, seg_size, 0,
                    (struct sockaddr*) client, sizeof(struct sockaddr_in));
                    
        if (bytes != seg_size) {
            snprintf(inf_msg_buf, INF_MSG_SIZE, 
                "Expected ack sent size %zd bytes, actual sent size %zd bytes",
                seg_size, bytes);
            s_exit_err(cpid, sockfd, inf_msg_buf, __LINE__);
        } else {
            tr_inf->expected_sq += 1;
        }
    } else {
        tr_inf->corrupt_segs++;
    }    
    
    return receiving;
}

static void s_exit_err(pid_t cpid, int sockfd, char* msg, int line) {
    if (cpid != -1) kill(cpid, SIGKILL);
       
    if (sockfd != -1) close(sockfd);
    
    fprintf(stderr, 
            "----------------------------------------------------------"
            "---------------------\n");
    if (errno) {
        fprintf(stderr, "SERVER ERROR: [%s:%d - %s]\n%s\n", __FILE__, line,
            strerror(errno), msg);
    } else {
        fprintf(stderr, "SERVER ERROR: [%s:%d]\n%s\n", __FILE__, line, msg);
    }      
    
    
    exit(EXIT_FAILURE);
}

static void s_print_summary(metadata_t* file_inf, trans_inf_t* tr_inf) {
    printf("\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
        "+++++++\n");
    printf("\nTransfer summary for output file: %s\n", file_inf->name);
    
    printf("        %ld bytes expected, %ld bytes valid payload\n", 
        (long) file_inf->size, (long) tr_inf->valid_payload);
    printf("            payload validation: ");
    if (file_inf->size == tr_inf->valid_payload) {
        printf("SUCCESS\n");
    } else {
        printf("FAILURE - see discrepancy in above values\n");
    }

    int segs_expected = file_inf->size / (PAYLOAD_SIZE - 1) +
        (file_inf->size % (PAYLOAD_SIZE - 1) ? 1 : 0);
    
    printf("        %d segments expected, %d valid segments received\n",
        segs_expected, tr_inf->total_segs - tr_inf->corrupt_segs);
    printf("            segment validation: ");
    if (segs_expected == (tr_inf->total_segs - tr_inf->corrupt_segs)) {
        printf("SUCCESS\n");
    } else {
        printf("FAILURE - see discrepancy in above values\n");
    }

    if (segs_expected) {
        printf("        %d total segments, %d corrupt segments\n", 
            tr_inf->total_segs, tr_inf->corrupt_segs);
        printf("            segment loss: %5.1f%%\n",
            100.0 * (float) tr_inf->corrupt_segs / (float) tr_inf->total_segs);
    }
    
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
        "+++++\n");
}

