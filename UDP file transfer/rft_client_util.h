/******** DO NOT EDIT THIS FILE ********/
#ifndef _RFT_CLIENT_H
#define _RFT_CLIENT_H
#include <stdio.h>
#include "rft_util.h"

/*
 * INTRODUCTION AND WHAT YOU HAVE TO DO
 * For this assignment, you have to implement the following functions declared
 * and documented in this file:
 *      init_segment
 *      read_data
 *      send_data
 *      send_file_with_timeout
 *      send_metadata
 *      set_socket_timeout
 *      set_udp_socket
 *      close_protocol
 *
 * You implement the functions in rft_client_util.c.
 *
 * Do not change any function signatures and do not change any other functions
 * or code provided.
 *
 * That is, you do not edit this file. You edit the functions listed above
 * in rft_client_util.c
 */

#define TFR_MODE_SIZE 3         // size of transfer mode command string
#define NORMAL_TFR_MODE "nm"    // normal transfer mode:
                                //      selects send_file_normal
#define TIMEOUT_TFR_MODE "wt"   // timeout transfer mode:
                                //      selects send_file_with_timeout
#define DEFAULT_TIMEOUT 2       // default timeout in seconds
#define DEFAULT_RETRIES 20      // default number of consecutive retries 
                                // before exiting

/* 
 * proto_state enum to determine which log messages are selected during 
 * protocol execution.
 * 
 * Assigning one of these states to the state field of a protocol structure
 * will select the corresponding logging statement when the log_protocol or
 * exit_err functions defined in rft_client_logging.h are called.
 *
 * The protocol state can also be used to control execution of a protocol. 
 * For example, to determine whether it is necessary to resend a data segment
 * after an ACK timeout.
 *
 * The enum values have been carefully selected. Only PS_RESEND_DATA
 * and PS_NO_ACK have odd values (1 and 3 respectively) and, therefore, have 
 * their 1 bit set. That is, PS_RESEND_DATA and PS_NO_ACK are the only states
 * for which PS_RESEND_DATA & proto.state is true. This is deliberate. 
 * All other odd enum values are unused with a name beginning  "UNUSED".
 *
 * & in the above is the bitwise operator (not the && logical operator). 
 * 
 * x & 1 is true if and only if the 2^0 bit of x is 1
 * 
 * For example:
 * if x is 2 (which means the lower byte is 0000 0010 - with the 2^1 bit set to
 * 1):
 *      x & 1 evaluates to:
 *            0000 0010 
 *          & 0000 0001
 *          = 0000 0000
 *          = 0 or false
 *
 * if x is 5 (which means the lower byte is 0000 0101 - with the 2^0 bit set
 * to 1 and the 2^2 bit set to 1):
 *      x & 1 evaluates to:
 *            0000 0101 
 *          & 0000 0001
 *          = 0000 0001
 *          = 1 or true
 *
 * See also: rft_client_logging.h and rft_client_logging.h to understand 
 * how logging and error exit works.
 */
typedef enum {
    PS_INIT,            // initial state
    PS_RESEND_DATA,     // resending data to the server
    PS_TFR_READY,       // ready for transfer, set after socket opened
    PS_NO_ACK,          // no ACK received from the server
    PS_START_SEND,      // start sending file
    UNUSED_A,
    PS_META_SENT,       // successful send of metatdata to server
    UNUSED_W,
    PS_DATA_READ,       // successful read of data from input file
    UNUSED_B,
    PS_SEND_DATA,       // sending data (as opposed to resending)
    UNUSED_C,
    PS_DATA_SENT,       // successful send of data to server
    UNUSED_D,
    PS_SOCKTOUT_SET,    // successful set of the socket timeout 
    UNUSED_V,
    PS_ACK_WAIT,        // waiting for an ACK from the server
    UNUSED_E,
    PS_ACK_RECV,        // ACK received from the server
    UNUSED_F,
    PS_SERVER_OK,       // (ack) server verified OK
    UNUSED_G,
    PS_TFR_COMPLETE,    // transfer completed with expected total file data
                        // transferred
    UNUSED_H,
    PS_TFR_MISMATCH,    // transfer completed with mismatch between total file
                        // data and the input file size
    UNUSED_Z,
    PS_EMPTY_FILE,      // empty input file detected (size: 0 bytes)
    UNUSED_I,
    PS_BAD_SOCKET,      // bad socket or failed to open
    UNUSED_J,
    PS_BAD_SERVER,      // bad server address parameter
    UNUSED_K,
    PS_BAD_META,        // failed to send metadata
    UNUSED_X,
    PS_BAD_READ,        // file read error
    UNUSED_L,
    PS_BAD_SEND,        // send error
    UNUSED_M,
    PS_BAD_ACK,         // bad ACK from server
    UNUSED_N,
    PS_BAD_ACK_SQ,      // ACK seq. number does not match data seq. number
    UNUSED_O,
    PS_BAD_S_SIZE,      // bad server address struct size in ACK
    UNUSED_P,
    PS_BAD_S_FAM,       // bad sin_family in server ACK
    UNUSED_Q,
    PS_BAD_S_PORT,      // bad sin_port in server ACK
    UNUSED_R,
    PS_BAD_S_ADDR,      // bad sin_addr in server ACK
    UNUSED_S,
    PS_EXCEED_RETRY,    // retry limit exceeded
    UNUSED_T,
    PS_BAD_SOCKTOUT,    // could not set the socket timeout option
    UNUSED_U,
    PS_BAD_LOG_FILE,    // source file name not set for logging
    UNUSED_Y,
    PS_BAD_LOG_LINE     // source file line not set for logging
} proto_state;

/*
 * protocol struct - alias protocol_t. 
 * The protocol structure provides the fields listed below to control the
 * execution of a transfer protocol and provide access to the resources needed
 * for a file transfer (such as the file to transfer, the open socket etc.)
 * 
 * FILE* log - the open log file/stream to write log messages to - by default
 *      set to stdout for normal output and stderr for error messages. Can be
 *      set to an ordinary file or to NULL to silence all logging except 
 *      error messages. This is typically set at client startup by a command
 *      line option.
 *
 * proto_state state - the current state of the protocol (see prot_state enum)
 * 
 * char* err_msg - an error message string to use for error reporting. There 
 *      are pre-defined error messages in the logging framework.
 * 
 * char in_fname[MAX_FILENAME_SIZE] - the name of the client-side input file 
 *      for transfer to the server
 * 
 * char out_fname[MAX_FILENAME_SIZE] - the name of the output file to create on
 *      the server as a result of the file transfer
 * 
 * off_t fsize - the size of the client-side input file (set when the file 
 *      status is determined before opening)
 * 
 * char server_addr[MAX_FILENAME_SIZE] - the address of the server to transfer
 *      the file to. This should be a well-formed IP address.
 * 
 * uint16_t server_port - the 16 bit port the server is listening on
 * 
 * FILE* in_file - a pointer to the open client-side input file to transfer
 *      (NULL if not open, set when the file is opened)
 * 
 * int sockfd - the socket to communicate with the server (-1 if not open, 
 *      set by set_udp_socket)
 * 
 * struct sockaddr_in server - the address structure of the server to
 *      communicate with (set by set_udp_socket)
 * 
 * socklen_t sockaddr_size - the size of a sockaddr_in struct
 * 
 * segment_t data - the protocol data segment for sending segments to the 
 *      server with payload that has been read from the input file
 * 
 * segment_t ack - the protocol ack segment for receiving ACKs from the server
 * 
 * size_t seg_size - the size of a segment_t struct
 * 
 * char* tfr_mode - the protocol tfr mode (NORMAL_TFR_MODE or TIMEOUT_TFR_MODE)
 * 
 * proto_state (*send_file_op)(protocol_t*) - a pointer to the function to use
 *      to send a file to the server. This is usually set to either 
 *      send_file_normal or send_file_with_timeout by a command line
 *      argument at client startup.
 * 
 * size_t tfr_bytes - the number of bytes remaining to be transferred during
 *      execution of a transfer. This is set to fsize (input file size) when 
 *      the input file status is obtained and decremented when data is 
 *      to be transferred is read from the input file.
 *
 * float loss_prob - the probability of loss or corruption of a data 
 *      transfer segment during the send_file_with_timeout protocol
 * 
 * time_t timeout_sec - the timeout in seconds to use for the protocol 
 *      with timeout (used to set the socket timeout property)
 * 
 * int curr_retry - the current number of consecutive retries 
 *      (retransmissions) following message loss or corruption
 *
 * int max_retries - the maximum number of consecutive retries 
 *      (retransmissions) to allow before exiting the client
 *
 * size_t total_file_data - the accumulated total file data transferred to the
 *      server as the result of a file transfer
 *
 * int total_segments - the accumulated total number of data segments
 *      transferred to the server as the result of a file transfer
 *
 * int resent_segments - the accumulated total number of data segments resent
 *      to the server as a result of timeouts during a file transfer
 *
 * See also: rft_client_logging.h
 */
typedef struct protocol protocol_t;
struct protocol {
    FILE* log;
    proto_state state;
    char* err_msg;
    char in_fname[MAX_FILENAME_SIZE];
    char out_fname[MAX_FILENAME_SIZE];
    off_t fsize;
    char server_addr[MAX_FILENAME_SIZE];
    uint16_t server_port;
    FILE* in_file;
    int sockfd;
    struct sockaddr_in server;
    socklen_t sockaddr_size;
    segment_t data;
    segment_t ack;
    size_t seg_size;
    char* tfr_mode;
    proto_state (*send_file_op)(protocol_t*);
    size_t tfr_bytes;
    float loss_prob;
    time_t timeout_sec;
    int curr_retry;
    int max_retries;
    size_t total_file_data;
    int total_segments;
    int resent_segments;
    void (*close)(protocol_t*);
};

/* 
 * init_protocol(protocol_t* proto) - initialises the protocol structure
 *
 * Documentation of this function is deliberately omitted - see the 
 * implementation in rft_client_util.c
 */
void init_protocol(protocol_t* proto);

/* 
 * init_segment(protocol_t* proto, seg_type type, bool payload_only)
 *      - initialises the segment identified by the given type.
 *
 *      If payload_only is false, the whole segment (data or ack as determined
 *      by the type parameter) is initialised as follows:
 *      - all bytes (and therefore fields) of the segment are zeroed
 *      - the segment type is set to the given type
 *
 *      If payload_only is true, the payload buffer of the segment identified
 *      by the given type is zeroed. No other field of the segment is affected.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *      client will terminate with a fatal memory error. If proto is not NULL, 
 *      the relevant segment of the given protocol structure is initialised.
 * type - the segment type to initialise (either the DATA_SEG or the ACK_SEG).
 * payload_only - a flag to only initialise the segment's payload buffer if
 *      payload_only is true. If payload_only is false, the whole segment is
 *      initialised.
 *
 * Return:
 * The function does not have a return value. Instead, the identified segment
 * of the given protocol structure is initialised as described above.
 *
 * See also: man pages for memset
 */
void init_segment(protocol_t* proto, seg_type type, bool payload_only);

/* 
 * read_data(protocol_t* proto) - read the next chunk of data from the 
 *      given proto's in_file into the proto's data segment payload buffer.
 *
 * On success the given proto structure is updated as follows:
 *  - file data is read from the proto's in_file to the proto's data payload 
 *    buffer
 *  - the data segment's file_data field is set to the number of bytes read 
 *      from the file
 *  - the tfr_bytes of the proto structure is updated so that it records 
 *      the remaining bytes to be read from the file after this segment is
 *      transferred. When all file bytes have been read, tfr_bytes will be
 *      zero.
 *      
 * read_data must ensure that the data segment's payload buffer is filled
 * with trailing zeroes. This ensures that the server can treat the data it
 * receives as a valid string. 
 * 
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *  client will terminate with a fatal memory error.
 *
 * Return:
 * The function returns one of the following protocol states:
 *  PS_DATA_READ if the data was successfully read from the input file (in which
 *      case the fields of the protocol structure are updated as noted above)
 *  PS_BAD_READ if reading from the input file fails (in which case case 
 *      the fields of the protocol structure cannot be relied upon)
 *
 * Errors:
 * If there are errors, the function returns PS_BAD_READ
 *
 * See also: man pages for fread and ferror
 */
proto_state read_data(protocol_t* proto);

/* 
 * send_data(protocol_t* proto) - send the given proto's data segment to 
 *      the server.
 *
 * send_data computes a checksum of the data and sets the data segments's
 * checksum prior to sending. If the transfer mode is with timeout (wt), 
 * the checksum should be corrupted with the loss probability specified 
 * by the proto structure.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has sockfd and 
 *      server fields. If proto is NULL, the client will terminate with a 
 *      fatal memory error.
 *
 * Return:
 * The function returns one of the following protocol states:
 *  PS_DATA_SENT if the data is  successfully sent
 *  PS_EXCEED_RETRY if the count of consecutive retries/retransmissions exceeds
 *      the maximum number of allowed retries
 *  PS_BAD_SEND if the there is an error sending the data segment (for example,
 *      the bytes sent is not the expected segment size)
 *
 * Errors:
 * If there are errors, the function returns PS_EXCEED_RETRY or PS_BAD_SEND
 */
proto_state send_data(protocol_t* proto);

/* 
 * send_file_normal(protocol_t* proto) - transfer the given protocol
 *      structure's file using the resources provided by the protocol
 *      structure, according to the normal file transfer protocol without
 *      timeout or retransmission.
 *
 * Documentation of this function is deliberately omitted - see the 
 * implementation in rft_client_util.c
 */
proto_state send_file_normal(protocol_t* proto);


/* 
 * send_file_with_timeout(protocol_t* proto) - transfer the given protocol
 *      structure's file using the resources provided by the protocol
 *      structure.
 *
 * This function is similar to the send_file_normal function except that it
 * resends data segments if no ACK for a segment is received from the server. 
 * To implement this, the function:
 *  - simulates network corruption or loss of data segments by
 *      injecting corruption into segment checksums. The checksum is computed
 *      in send_data.
 *  - times-out when waiting to receive an ACK from the server
 *      for a data segment. The server does not ACK corrupted segments.
 *      Therefore, this client function will timeout waiting for an ACK 
 *      for a corrupted segment. When the timeout expires, the 
 *      function resends the data segment. set_socket_timeout is used to set
 *      the timeout. 
 *
 * The file is sent in chunks as the payload of a succession of one or 
 * more data segments until the whole file has been transferred. The read_data
 * function reads from the file in payload size chunks. The send_data function
 * sends the segments.
 *
 * The server expects each chunk of a file to be a correctly terminated
 * string.
 *
 * Data and ACK messages are sent as segment_t structs defined in rft_util.h
 *
 * This function has the following side effects:
 *  - output of information messages for the user to follow progress of the
 *      file transfer.
 *  - exit of the client on detection of an error in the file transfer 
 *      process. Errors may arise from reading the file on the client 
 *      side or from sending the file to the server or from receiving 
 *      ACKS from the server (that is, actual errors in receipt of ACKS as
 *      opposed to timeout of ACKS). 
 *
 * During execution of this function, the protocol goes through the same
 * states as for send_file_normal with the following exception:
 *  - non-receipt of an ACK leads to the PS_NO_ACK state, which should be 
 *      logged, and then the PS_RESEND_DATA state after logging.
 *
 * In addition to updating the proto state field, this function updates fields
 * to record the progress of a file transfer. This includes the number of
 * consecutive retries.
 *
 * Functions of the rft_client_logging library are used for output.
 *
 * If the size of the input file to transfer is 0, this function returns
 * PS_EMPTY_FILE immediately.
 * 
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has all 
 *      the information required for the file transfer. If proto is
 *      NULL, the client will terminate with a fatal memory error.
 * 
 * Return:
 * The function returns one of the following protocol states:
 *  PS_EMPTY_FILE if the input file is empty
 *  PS_TFR_COMPLETE if the transfer completed successfully and the total data
 *      transferred is equal to the input file size
 *  PS_TFR_MISMATCH if the transfer completed but the total data transferred
 *      is not equal to the input file size
 * In addition, if the input file size is greater than 0, the following fields
 *  of the proto struct are updated:
 *      - total segments transferred
 *      - number of segments resent due to ACK timeouts
 *      - total payload transferred 
 * Other fields of the structure are also updated during progress of the 
 * a transfer.
 *
 * Errors:
 * For errors other than PS_TFR_MISMATCH (see return value), the function causes
 * the client to exit with an appropriate error state.
 *
 * Relevant functions/libraries include: rft_client_logging library,
 *  set_socket_timeout, read_data, send_data, recvfrom system library function.
 *
 * See also: send_file_normal
 */
proto_state send_file_with_timeout(protocol_t* proto);

/* 
 * send_metadata(protocol_t* proto) - send protocol metadata to the server.
 *
 * Sending metadata starts a transfer by sending the following information to
 * the server in the metadata_t struct (defined in rft_util.h):
 *      size - the size of the file to send in bytes
 *      name - the name of the file to create on the server
 *  
 * This function does not set any of the fields of the proto struct.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has all 
 *      the information required to send metadata from client to server. 
 *      If proto is NULL, the client will terminate with a fatal memory error.
 *
 * Return:
 * The function returns one of the following protocol states:
 *  PS_META_SENT if the metadata was successfully sent
 *  PS_BAD_META otherwise
 *
 * Errors:
 * If there are errors, the function returns PS_BAD_META.
 */
proto_state send_metadata(protocol_t* proto);
    
/* 
 * set_socket_timeout(protocol_t* proto) - set the timeout of the proto's socket
 *      for receiving an ACK to the timeout_sec field of the proto.
 *
 * A timeout is a socket level option that can be set for sending and/or 
 * receiving on a socket. See setsockopt man page or:
 * https://man7.org/linux/man-pages/man3/setsockopt.3p.html and related 
 * pages.
 *
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *      client will terminate with a fatal memory error.
 *
 * Return:
 * The function returns one of the following protocol states:
 *  PS_SOCKTOUT_SET if setting the timeout succeeds
 *  PS_BAD_SOCKTOUT otherwise
 *
 * Errors:
 * If there are errors, the function returns PS_BAD_META.
 */
proto_state set_socket_timeout(protocol_t* proto);

/* 
 * set_udp_socket(protocol_t* proto) - opens a UDP socket to communicate with
 *      the server and sets the sockfd field of the given protocol structure 
 *      to the open socket. If opening the socket succeeds, this function also
 *      updates the sin_family, sin_addr.s_addr and sin_port fields of the
 *      protocol structure's server sockaddr_in struct as appropriate for
 *      communication with the server and as specified by the protocol
 *      structure's server_addr and server_port
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, 
 *      the client will terminate with a fatal memory error.
 *
 * Return:
 * The function returns one of the following protocol states:
 *  PS_TFR_READY if the socket is opened and protocol structures fields are 
 *      successfully updated
 *  PS_BAD_SOCKET if opening the socket fails (see Errors)
 *  PS_BAD_SERVER if there is an error updating protocol structure's server
 *      (see Errors)
 * 
 * Errors:
 * If opening the socket fails, the sockfd field of the protocol structure 
 * will be set to -1, the server field will not be updated and PS_BAD_SOCKET
 * is returned.
 * If opening the socket succeeds but updating the protocol structure's server
 * fails, PS_BAD_SERVER is returned. In this case it is the responsibility of 
 * the caller of set_udp_socket to close the socket. 
 *
 * See also: man pages for socket, htons and inet_aton
 */
proto_state set_udp_socket(protocol_t* proto);

/* 
 * close_protocol(protocol_t* proto) - closes open resources associated with 
 *      the given protocol structure
 *
 * The resources that are possibly open are:
 *  - the input file (the relevant field of the struct will be NULL if it 
 *      is not open)
 *  - the socket (the relevant field of the struct will be -1 if it is not
 *      open)
 *  - the logging output file (the relevant field of the struct will be NULL
 *      if it is not open)
 * 
 * If the logging output is set to stdout or stderr this function must not close
 * the log.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, 
 *      the client will terminate with a fatal memory error.
 *
 * Return:
 * There is no return value.
 * 
 * Errors:
 * There is no error handling of close library functions. The function succeeds
 * or fails silently.
 *
 * See also: appropriate close library functions
 */
void close_protocol(protocol_t* proto);

#endif


