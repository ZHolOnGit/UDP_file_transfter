/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "munit.h"
#include "rft_client_util.h"

static MunitResult test_init_protocol_def(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_protocol_undef(const MunitParameter params[],
    void* fixture);
    
static MunitTest tests[] = {
    { "/test_init_protocol_def", test_init_protocol_def, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_protocol_undef", test_init_protocol_undef, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rftcu_init_protocol", tests, NULL, 1, MUNIT_SUITE_OPTION_NONE 
};    


int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static MunitResult verify_initialised(protocol_t* proto) {
    assert_ptr_equal(proto->log, stdout);
    assert_int(proto->state, ==, PS_INIT);
    assert_null(proto->err_msg);
    
    for (int i = 0; i < MAX_FILENAME_SIZE; i++) {
        assert_char(proto->in_fname[i], ==, 0);
        assert_char(proto->out_fname[i], ==, 0);
        assert_char(proto->server_addr[i], ==, 0);
    }
    
    assert_size(proto->fsize, ==, 0);
    assert_uint16(proto->server_port, ==, 0);
    assert_null(proto->in_file);
    assert_int(proto->sockfd, ==, -1);
    assert_size(proto->sockaddr_size, ==, sizeof(struct sockaddr_in));
    assert_size(proto->seg_size, ==, sizeof(segment_t));
    assert_null(proto->tfr_mode);
    assert_null(proto->send_file_op);
    assert_size(proto->tfr_bytes, ==, 0);
    assert_float(proto->loss_prob, ==, 0.0);
    assert_int(proto->timeout_sec, ==, DEFAULT_TIMEOUT);
    assert_int(proto->curr_retry, ==, 0);
    assert_int(proto->max_retries, ==, DEFAULT_RETRIES);
    assert_size(proto->total_file_data, ==, 0);
    assert_int(proto->total_segments, ==, 0);
    assert_int(proto->resent_segments, ==, 0);
    assert_ptr_equal(proto->close, close_protocol);

    char* srvr = (char*) &proto->server;
    int i = 0;
    for (i = 0; i < proto->sockaddr_size; i++)
        assert_char(srvr[i], ==, 0);
    
    assert_int(i, ==, sizeof(struct sockaddr_in));
    
    /* 
     * note: tests of segment initialisation are delegated to 
     * test_rftcu_init_segment
     */

    return MUNIT_OK;
}

static MunitResult test_init_protocol_def(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    
    proto.fsize = 128;
    proto.server_port = 8888;
    proto.log = stderr;
    proto.tfr_mode = "nm";
    proto.tfr_bytes = 660;
    proto.curr_retry = 10;
    proto.sockfd = 10;
    proto.total_segments = 100;
    proto.resent_segments = 50;
    
    init_protocol(&proto);

    return verify_initialised(&proto);
}
static MunitResult test_init_protocol_undef(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    
    init_protocol(&proto);

    return verify_initialised(&proto);
}

